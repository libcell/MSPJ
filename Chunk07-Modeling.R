
################################################################################
#    &&&....&&&    % Project: MSPJ approach for identification of DEGs         #
#  &&&&&&..&&&&&&  % Author: Bo Li, Huachun Yin, Jingxin Tao, Youjin Hao       #
#  &&&&&&&&&&&&&&  % Date: Jun. 1st, 2020                                      #
#   &&&&&&&&&&&&   %                                                           #
#     &&&&&&&&     % Environment: R version 3.5.3;                             #
#       &&&&       % Platform: x86_64-pc-linux-gnu (64-bit)                    #
#        &         %                                                           #
################################################################################

### ****************************************************************************
### code chunk number 06: Data analysis based permutation test.
### ****************************************************************************

### Reference: Implementing a class of permutation tests: the coin package, 2008. 
### Ref: https://rcompanion.org/handbook/K_01.html

# input: eset - a gene expression matrix, genes in lines and samples in columns. 
#        set.n - the number of the subgroups generated by sampling. 
# output: degs - a genelist, including the gene names, pooled SMDs, and so on. 

### ------------------------------------------------------------------------ ###
### Step-01. Loading the gene expression data in *.csv

# eset <- get(load("seq.matrix.RData"))

# rm(seq.matrix)

### ------------------------------------------------------------------------ ###
### Step-02. Constructing the models based on SVM algorithm. 

# Using the testing dataset, iris. 

X <- iris[1:99, names(iris) != "Species"]

y <-  as.character(iris$Species)[1:99]

# please select the fold number, for k-fold CV. 

folds <- 10

test.fold <- split(sample(1:length(y)), 1:folds) # ignore warning

all.pred.tables <- lapply(1:folds, function(i) {
  
  test.id <- test.fold[[i]]
  
  X.train <- X[-test.id, ]
  
  y.train <- as.factor(y[-test.id])
  
  model <- svm(X.train, y.train, kernel = "radial", prob = TRUE, cross = 0) # some tuning may be needed
  
  predict.test <- predict(model, X[test.id, ], prob = TRUE)
  
  prob.benign <- attr(predict.test, "probabilities")[, 2]
  
  data.frame(y.test = y[test.id], y.pred = prob.benign) # returning this
  
})

full.pred.table <- do.call(rbind, all.pred.tables)

res.roc <- roc(full.pred.table$y.test, full.pred.table$y.pred)

plot(res.roc, col = "red") 
# lines(perf, col = "green")

auc.value <- auc(res.roc)

library(ROCR)



library(caret)
# library(klaR)
# load the iris dataset
data(iris)
# define an 80%/20% train/test split of the dataset
split=0.80
trainIndex <- createDataPartition(iris$Species, p=split, list=FALSE)
data_train <- iris[ trainIndex,]
data_test <- iris[-trainIndex,]
# train a naive bayes model
model <- NaiveBayes(Species~., data=data_train)
# make predictions
x_test <- data_test[, 1:4]
y_test <- data_test[, 5]
predictions <- predict(model, x_test)
#  summarize results
x <- confusionMatrix(predictions$class, y_test)






# End. 


