
################################################################################
#    &&&....&&&    % Project: MSPJ approach for identification of DEGs         #
#  &&&&&&..&&&&&&  % Author: Bo Li, Huachun Yin, Jingxin Tao, Youjin Hao       #
#  &&&&&&&&&&&&&&  % Date: Jun. 1st, 2020                                      #
#   &&&&&&&&&&&&   %                                                           #
#     &&&&&&&&     % Environment: R version 3.5.3;                             #
#       &&&&       % Platform: x86_64-pc-linux-gnu (64-bit)                    #
#        &         %                                                           #
################################################################################

### ****************************************************************************
### code chunk number 06: Data analysis based permutation test.
### ****************************************************************************

### Reference: Implementing a class of permutation tests: the coin package, 2008. 
### Ref: https://rcompanion.org/handbook/K_01.html

# input: eset - a gene expression matrix, genes in lines and samples in columns. 
#        set.n - the number of the subgroups generated by sampling. 
# output: degs - a genelist, including the gene names, pooled SMDs, and so on. 

### ------------------------------------------------------------------------ ###
### Step-01. Loading the gene expression data in *.csv

# eset <- get(load("seq.matrix.RData"))

# rm(seq.matrix)

### ------------------------------------------------------------------------ ###
### Step-02. Setting the parameters used for re-sampling.

# set.n: the times of resampling, or the number of sub-groups.   
# size.min: the lower limit of sample size in each group.
# size.max: the maximum sample size in each group. 
# ord.gene: which gene you focused on. 


# Data Split
# load the libraries

X = iris[1:100, names(iris) != "Species"]
y = as.character(iris$Species)[1:100]

folds <- 10

test.fold <- split(sample(1:length(y)), 1:folds) #ignore warning

all.pred.tables <-  lapply(1:folds, function(i) {
  
  test <- test.fold[[i]]
  
  Xtrain <- X[-test, ]
  
  ytrain <- as.factor(y[-test])
  
  sm <- svm(Xtrain, ytrain, cost = 1, prob = TRUE) # some tuning may be needed
  
  prob.benign <- attr(predict(sm, X[test,], prob = TRUE), "probabilities")[, 2]
  
  data.frame(ytest = y[test], ypred = prob.benign) # returning this
  
})

full.pred.table <- do.call(rbind, all.pred.tables)

res.roc <- roc(full.pred.table$ytest, full.pred.table$ypred)

plot(res.roc, col = "red") 

auc.value <- auc(res.roc)



library(caret)
# library(klaR)
# load the iris dataset
data(iris)
# define an 80%/20% train/test split of the dataset
split=0.80
trainIndex <- createDataPartition(iris$Species, p=split, list=FALSE)
data_train <- iris[ trainIndex,]
data_test <- iris[-trainIndex,]
# train a naive bayes model
model <- NaiveBayes(Species~., data=data_train)
# make predictions
x_test <- data_test[, 1:4]
y_test <- data_test[, 5]
predictions <- predict(model, x_test)
# summarize results
confusionMatrix(predictions$class, y_test)



# End. 


