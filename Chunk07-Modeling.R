
################################################################################
#    &&&....&&&    % Project: MSPJ approach for identification of DEGs         #
#  &&&&&&..&&&&&&  % Author: Bo Li, Huachun Yin, Jingxin Tao, Youjin Hao       #
#  &&&&&&&&&&&&&&  % Date: Jun. 1st, 2020                                      #
#   &&&&&&&&&&&&   %                                                           #
#     &&&&&&&&     % Environment: R version 3.5.3;                             #
#       &&&&       % Platform: x86_64-pc-linux-gnu (64-bit)                    #
#        &         %                                                           #
################################################################################

### ****************************************************************************
### code chunk number 06: Data analysis based permutation test.
### ****************************************************************************

### Reference: Implementing a class of permutation tests: the coin package, 2008. 
### Ref: https://rcompanion.org/handbook/K_01.html

# input: eset - a gene expression matrix, genes in lines and samples in columns. 
#        set.n - the number of the subgroups generated by sampling. 
# output: degs - a genelist, including the gene names, pooled SMDs, and so on. 

### ------------------------------------------------------------------------ ###
### Step-01. Loading the gene expression data in *.csv

eset <- get(load("seq.matrix.RData"))

rm(seq.matrix)

### ------------------------------------------------------------------------ ###
### Step-02. Setting the parameters used for re-sampling.

# set.n: the times of resampling, or the number of sub-groups.   
# size.min: the lower limit of sample size in each group.
# size.max: the maximum sample size in each group. 
# ord.gene: which gene you focused on. 

if (!require("coin")) install.packages("coin")

library(coin)

#. set.seed(1)
#. n <- 100
#. tr <- rbinom(100, 1, 0.5)
#. y <- 1 + tr + rnorm(n, 0, 3)
#. diff(by(y, tr, mean))
#. s <- sample(tr, length(tr), FALSE)
#. diff(by(y, s, mean))
#. dist <- replicate(2000, diff(by(sample(y, length(y), FALSE), sample(tr, length(tr), FALSE), mean)))
#. hist(dist, xlim = c(-3, 3), col = "black", breaks = 100)
#. abline(v = diff(by(y, tr, mean)), col = "blue", lwd = 2)
#. sum(dist > diff(by(y, tr, mean)))/2000  # one-tailed test

# for coin package. 

# independence_test(y ~ tr, alternative = "greater")  # one-tailed
# independence_test(y ~ tr, alternative = "two.sided")  # two-tailed

library(FSA)

all.genes <- names(input)[-1]

deg.count <- NULL

for (g in all.genes) {
  
  tmp <- Summarize(get(g) ~ sam.lab, data = input, digits = 3)
  
  # print(tmp)
  
  # boxplot(get(g) ~ sam.lab, data = input)
  
  deg.per <- try(independence_test(get(g) ~ sam.lab, data = input), silent = FALSE)
  
  # deg.Z <- deg.per@statistic@teststatistic
  deg.p <- deg.per@distribution@pvalue(deg.per@statistic@teststatistic)
  
  # This variable, deg.count, stores all the differentially expressed genes.
  
  if (!is.na(deg.p) & deg.p < 0.05) deg.count <- c(deg.count, g) else next
  
}

# For permutation test of independence
# For two groups as independent samples, 
# and tests if there is a difference in values between the two groups.

# For permutation test of symmetry. 
# For two groups as having paired or repeated data, paired within Individual.

# deg.per <- symmetry_test(g10000 ~ sam.lab | Individual, data = input)

#. class(deg.per)
#. getMethod("show","ScalarIndependenceTest")

# End. 

fc <- NULL
p <- NULL
for (i in 2:20001) {
  
  print(i)
  x <- mean(input[, i][1:15])/mean(input[, i][16:25])
  y <- t.test(input[, i][1:15], input[, i][16:25], paired = FALSE)
  #print("++++++++++++++++++++++++++++++++++++++++")
  
  fc <- c(fc, x)
  p <- c(p, y$p.value)
  #Sys.sleep(3)
}

plot(fc, ylim = c(0.9, 1.1))

table(((fc < 0.5 | fc > 2) & p < 0.05)[1:500])

hist(p, breaks = 100)

table(p[1:500] < 0.05)

hist(input$g1, breaks = 10)

# Data Split
# load the libraries
library(caret)
library(klaR)
# load the iris dataset
data(iris)
# define an 80%/20% train/test split of the dataset
split=0.80
trainIndex <- createDataPartition(iris$Species, p=split, list=FALSE)
data_train <- iris[ trainIndex,]
data_test <- iris[-trainIndex,]
# train a naive bayes model
model <- NaiveBayes(Species~., data=data_train)
# make predictions
x_test <- data_test[, 1:4]
y_test <- data_test[, 5]
predictions <- predict(model, x_test)
# summarize results
confusionMatrix(predictions$class, y_test)








