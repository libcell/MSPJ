
################################################################################
#    &&&....&&&    % Project: MSPJ approach for identification of DEGs         #
#  &&&&&&..&&&&&&  % Author: Bo Li, Huachun Yin, Jingxin Tao, Youjin Hao       #
#  &&&&&&&&&&&&&&  % Date: Jun. 1st, 2020                                      #
#   &&&&&&&&&&&&   %                                                           #
#     &&&&&&&&     % Environment: R version 3.5.3;                             #
#       &&&&       % Platform: x86_64-pc-linux-gnu (64-bit)                    #
#        &         %                                                           #
################################################################################

### ****************************************************************************
### code chunk number 05: Gene selection based on SVM-RFE algorithm.
### ****************************************************************************

### Title: A novel meta-analytical approach to improve identification of DEGs. 

# input: eset - a gene expression matrix, genes in lines and samples in columns. 
#        set.n - the number of the subgroups generated by sampling. 
# output: degs - a genelist, including the gene names, pooled SMDs, and so on. 

### ------------------------------------------------------------------------ ###
### Step-01. Data preprocessing for whole dataset, seq.matrix or mcr.matrix. 

#-- seq.matrix.RData: simulated RNA-seq data; 
#-- mcr.matrix.RData: simulated microarray data. 

if (all(as.integer(eset) == as.numeric(eset))) {
  
  #-- Filtering the genes with low-expression levels. 
  
  cpms <- cpm(eset)
  keep <- rowSums(cpms>1) >= 3
  eset <- eset[keep, ]
  
  #-- Data normalization for gene expression matrix filled by counts. 
  
  DGElist <- DGEList(counts = eset)
  
  DGElist <- calcNormFactors(DGElist, method = "upperquartile")
  
  #. boxplot(log2(DGElist$count))
  #. plotMDS(DGElist)
  
  eset <- DGElist$count  
  
}

### End of Step-01.
### ------------------------------------------------------------------------ ###

### ------------------------------------------------------------------------ ###
### Step-02. Preparing the data file used for SVM-RFE gene selection.

sam.lab <- sapply(colnames(eset), function(x) strsplit(x, "-")[[1]][1])

names(sam.lab) <- NULL

eset.mat <- as.data.frame(t(eset))

input <- cbind(sam.lab, eset.mat)

input <- as.data.frame(input)

print(input[1:10, 1:10])

save(input, file = "input.RData")

### End of Step-02.
### ------------------------------------------------------------------------ ###

### ------------------------------------------------------------------------ ###
### Step-03. Gene selection using simple SVM-RFE algorithm.

set.seed(1)

# Basic usage: when k = 1, it was standard SVM-RFE; or, multiple SVM-RFE. 
# halve.above - allowing you cut the features in half each round. 

ranked.feat <- svmRFE(input, k = 5, halve.above = 100)

### End of Step-03.
### ------------------------------------------------------------------------ ###

### ------------------------------------------------------------------------ ###
### Step-04. Gene selection using multiple SVM-RFE algorithm.

# 1) Generating multiple sub-groups based resampling, and setting up cross validation.

nfold <- 10
nrows <- nrow(input)
folds <- rep(1:nfold, len=nrows)[sample(nrows)]
folds
folds <- lapply(1:nfold, function(x) which(folds == x))
folds

# 2) Perform feature ranking on all training sets

results <- lapply(folds, svmRFE.wrap, input, k = 5, halve.above = 100)
length(results)
results

# 3) Obtain top features across ALL folds

top.features <- WriteFeatures(results, input, save = FALSE)
head(top.features)

# 4) Selecting the top n genes as the DEGs identified by SVM-RFE method, eg. 500. 

deg.svm <- top.features$FeatureName[1:500]

deg.svm <- as.character(deg.svm)

deg.svm

# Estimate generalization error using a varying number of top features
#. featsweep <- lapply(1:12, FeatSweep.wrap, results, input)
#. featsweep
# Make plot
#. no.info <- min(prop.table(table(input[, 1])))
#. errors  <- sapply(featsweep, function(x) ifelse(is.null(x), NA, x$error))
#. dev.new(width = 4, height = 4, bg = 'white')
#. PlotErrors(errors, no.info = no.info)
#. dev.off()

### End of Step-04.
### ------------------------------------------------------------------------ ###

