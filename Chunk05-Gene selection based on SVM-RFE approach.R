
################################################################################
#    &&&....&&&    % Project: MSPJ approach for identification of DEGs         #
#  &&&&&&..&&&&&&  % Author: Bo Li, Huachun Yin, Jingxin Tao, Youjin Hao       #
#  &&&&&&&&&&&&&&  % Date: Jun. 1st, 2020                                      #
#   &&&&&&&&&&&&   %                                                           #
#     &&&&&&&&     % Environment: R version 3.5.3;                             #
#       &&&&       % Platform: x86_64-pc-linux-gnu (64-bit)                    #
#        &         %                                                           #
################################################################################

### ****************************************************************************
### code chunk number 05: .
### ****************************************************************************

### Title: A novel meta-analytical approach to improve identification of DEGs. 

# input: eset - a gene expression matrix, genes in lines and samples in columns. 
#        set.n - the number of the subgroups generated by sampling. 
# output: degs - a genelist, including the gene names, pooled SMDs, and so on. 

### ------------------------------------------------------------------------ ###
### Step-01. Loading the gene expression data in *.csv

eset <- get(load("seq.matrix.RData"))
rm(seq.matrix)

### End of Step-01.
### ------------------------------------------------------------------------ ###

### ------------------------------------------------------------------------ ###
### Step-02. Data preprocessing for seq.matrix. 

### Filtering the genes with low-expression levels. 

if (all(as.integer(eset) == as.numeric(eset))) {
  
  cpms <-  cpm(eset)
  keep <- rowSums(cpms>1) >= 3
  eset <- eset[keep, ]
  
}

### Data normalization for gene expression matrix filled by counts. 

DGElist <- DGEList(counts = eset)

DGElist <- calcNormFactors(DGElist, method = "upperquartile")

#. boxplot(log2(DGElist$count))

# plotMDS(DGElist)

eset <- DGElist$count

### End of Step-02.
### ------------------------------------------------------------------------ ###

### ------------------------------------------------------------------------ ###
### Step-02. Setting the parameters used for re-sampling.

sam.lab <- sapply(colnames(eset), function(x) strsplit(x, "-")[[1]][1])  
names(sam.lab) <- NULL

eset.mat <- as.data.frame(t(eset))
# eset.mat[1:9, 1:6]

input <- cbind(sam.lab, eset.mat)

input <- as.data.frame(input)

input[1:10, 1:10]


set.seed(12)
library(e1071)
#. source('Chunk04-SVM-RFE implementation by johncolby.R')

# load("input.Rdata")

# Take a look at the expected input structure
dim(input)
# input[1:5, 1:5]

# Basic usage: when k = 1, it was standard SVM-RFE; or, multiple SVM-RFE. 

# halve.above - allowing you cut the features in half each round. 

ranked.feat <- svmRFE(input, k = 5, halve.above = 100)

### ------------------------------------------------------------------------ ###
### Step-03. Generating multiple sub-groups based resampling for primary study. 

# Set up cross validation
nfold <- 10
nrows <- nrow(input)
folds <- rep(1:nfold, len=nrows)[sample(nrows)]
folds
folds <- lapply(1:nfold, function(x) which(folds == x))
folds

# Perform feature ranking on all training sets

results <- lapply(folds, svmRFE.wrap, input, k = 10, halve.above = 100)
length(results)
results

# Obtain top features across ALL folds

top.features <- WriteFeatures(results, input, save = FALSE)
head(top.features)

# Estimate generalization error using a varying number of top features

featsweep <- lapply(1:5, FeatSweep.wrap, results, input)
featsweep

# Make plot
no.info <- min(prop.table(table(input[,1])))
errors  <- sapply(featsweep, function(x) ifelse(is.null(x), NA, x$error))

dev.new(width = 4, height = 4, bg = 'white')
PlotErrors(errors, no.info = no.info)
dev.off()


# End. 


